#!/usr/bin/env python
import tempfile
from subprocess import *
import sys
import os
import re
import BugleChecks

Import('envs', 'aspects', 'targets', 'libraries', 'srcdir')

class TestFailed(Exception):
    def __init__(self, value):
        Exception.__init__(self, value)

def run_log_suite(target, testprog, env, suite, chain):
    (handle, logfile) = tempfile.mkstemp('.log')
    reflog = None
    try:
        try:
            os.close(handle)
            env = dict([(key, str(value)) for (key, value) in env['ENV'].items()])
            env['LD_PRELOAD'] = 'libbugle.so'
            env['BUGLE_CHAIN'] = chain

            sp = Popen([testprog[0].abspath, '--suite', suite, '--log', logfile],
                    stdout = PIPE, env = env)
            (out, err) = sp.communicate()
            errcode = sp.wait()
            if errcode != 0:
                raise TestFailed, 'exit code ' + str(errcode)

            lines = out.splitlines()
            orig_lines = [x for x in lines] # Deep copy
            if len(lines) == 0:
                raise TestFailed, 'no standard output'
            # Some filters output logging on shutdown, AFTER the status is
            # written, so look for status anywhere
            statuses = []
            for i in range(len(lines)):
                if lines[i] == 'FAILED':
                    raise TestFailed('')
                elif lines[i] in ('SKIPPED', 'RAN'):
                    statuses.append(i)
            if len(statuses) == 0:
                raise TestFailed('Did not find any status lines')
            if not 'RAN' in lines:
                print "SKIPPED  Test `" + suite + "'"
                return
            statuses.reverse()
            for lineno in statuses:
                del lines[lineno]

            reflog = file(logfile, 'r')
            reflines = reflog.readlines()
            reflines = ['^' + x.rstrip('\r\n') + '$' for x in reflines]
            if len(reflines) == 0 and 'RAN' in lines:
                raise TestFailed, 'no reference output'
            # There will be some startup stuff not in the log
            while len(lines) > 0 and not re.match(reflines[0], lines[0]):
                del lines[0]
            if len(lines) == 0:
                raise TestFailed, 'did not match ' + reflines[0] + ' at line 1\n' + '\n'.join(orig_lines)
            if len(lines) < len(reflines):
                raise TestFailed, 'not enough output'
            for i in range(len(reflines)):
                if not re.match(reflines[i], lines[i]):
                    raise TestFailed, "`" + lines[i] + "' did not match `" + reflines[i] + "' at line " + str(i + 1) + '\n' + '\n'.join(orig_lines)

            print "PASSED  Test `" + suite + "'"
        except TestFailed, (msg,):
            if msg != '':
                msg = ' (' + msg + ')'
            print "FAILED  Test `" + suite + "'" + msg
            return 1
    finally:
        if reflog is not None:
            reflog.close()
        os.remove(logfile)

def make_log_suite(name, chain):
    def action(target, source, env):
        return run_log_suite(target, source, env, name, chain)
    return action

def simple_test(name):
    return test_env.Program(
            target = name,
            source = [name + '.c'])

if 'tests' not in aspects['parts']:
    Return()

test_env = envs['host'].Clone()
plain_tests = ['string', 'math', 'threads']
log_suites = []  # Tuples of (source file, suite name, filter chain)
simple_tests = []
test_deps = []
test_sources = ['test.c']
bugle_path = os.path.dirname(targets['bugle'].out[0].abspath)

if 'interceptor' not in aspects['parts']:
    print 'WARNING: cannot run some tests without interceptor. They will be skipped'
else:
    if aspects['gltype'] == 'gl':
        glew_lib = False
        glut_lib = False
        glu_lib = False

        conf = Configure(test_env, custom_tests = BugleChecks.tests)
        if conf.CheckLibWithHeader('GLEW', 'GL/glew.h', 'c', autoadd = False):
            glew_lib = 'GLEW'
        elif conf.CheckLibWithHeader('glew32', 'GL/glew.h', 'c', autoadd = False):
            glew_lib = 'glew32'
        if conf.CheckLibWithHeader('glut', 'GL/glut.h', 'c', autoadd = False):
            glut_lib = 'glut'
        elif conf.CheckLibWithHeader('glut32', 'GL/glut.h', 'c', autoadd = False):
            glut_lib = 'glut32'
        elif conf.CheckLibWithHeader('freeglut', 'GL/glut.h', 'c', autoadd = False):
            glut_lib = 'freeglut'
        if conf.CheckLibWithHeader('GLU', ['GL/glut.h', 'GL/glu.h'], 'c', autoadd = False):
            glu_lib = 'GLU'
        elif conf.CheckLibWithHeader('glu32', ['GL/glut.h', 'GL/glu.h'], 'c', autoadd = False):
            glu_lib = 'GLU32'

        use_gl = glew_lib and glut_lib and glu_lib
        if use_gl:
            conf.env.Append(LIBS = [glew_lib, glut_lib, glu_lib])
            test_env = conf.Finish()

            test_env.Append(LIBS = libraries)
            # libdl should be pulled in by dependencies, but since the dlopen
            # test calls it directly we will explicitly list it. This is apparently
            # needed due to some symbol version weirdness on Fedora 14 (bug #84).
            if aspects['platform'] == 'posix':
                test_env.Append(LIBS = ['dl'])
            # The ARB_create_context GLX test calls X11 directly instead of using GLUT
            if aspects['glwin'] == 'glx':
                test_env.Append(LIBS = ['X11'])
            test_env.Append(CPPDEFINES = ['TEST_GL'])
            test_env['ENV']['BUGLE_FILTER_DIR'] = os.path.join(bugle_path, 'filters')
            test_env['ENV']['BUGLE_FILTERS'] = srcdir.File('filters').abspath

            test_deps.append(targets['bugle'].out)

            plain_tests.extend([
                'errors',
                'interpose',
                'procaddress'])
            log_suites.extend([
                ('dlopen.c', 'dlopen', 'trace'),
                ('draw.c',   'draw_client', 'trace'),
                ('draw.c',   'draw_vbo', 'trace'),
                ('extoverride.c', 'extoverride', 'extoverride'),
                ('pbo.c', 'pbo', 'trace'),
                ('pointers.c', 'pointers', 'checks'),
                ('queries.c', 'queries', 'trace'),
                ('setstate.c', 'setstate', 'trace'),
                ('showextensions.c', 'showextensions', 'showextensions'),
                ('texcomplete.c', 'texcomplete', 'checks'),
                ('triangles.c', 'triangles', 'triangles')
                ])
            if aspects['glwin'] == 'glx':
                log_suites.append(
                    ('arbcreatecontext.c', 'ARB_create_context', 'trace'))
            simple_test('objects')
            simple_test('shadertest')
            simple_test('textest')
            if aspects['glwin'] == 'glx':
                simple_test('threads1')
                simple_test('threads2')
        else:
            print 'WARNING: GLEW, GLUT and GLU are required for some tests'
    else:
        print 'WARNING: not all tests run on this variant of OpenGL'

test_env.AppendENVPath('LD_LIBRARY_PATH', bugle_path) # For Linux
test_env.AppendENVPath('PATH', bugle_path)            # For Windows
test_env_run = test_env.Clone()
test_env_run.AppendENVPath('LD_PRELOAD', 'libbugle.so')   # For Linux

test_sources += [x + '.c' for x in plain_tests]
test_sources += set([x[0] for x in log_suites])
bugletest = test_env.Program(
        target = 'bugletest',
        source = test_sources + targets['bugleutils'].out)

test = test_env.Command(Value(''), bugletest, Action('${SOURCE.path}', 'Running basic tests'))
test_env_run.Depends(test, test_deps)
test_env_run.Depends(test, '../filters')
test_env_run.AlwaysBuild(test)
test_env_run.Alias('test', test)

for source, suite, chain in log_suites:
    message = None
    if aspects['quiet'] == 'no':
        message = 'Running suite %s' % (suite,)
    test = test_env_run.Command(Value(''), bugletest,
            Action(make_log_suite(suite, chain), message))
    test_env_run.Depends(test, test_deps)
    test_env_run.Depends(test, '../filters')
    test_env_run.AlwaysBuild(test)
    test_env_run.Alias('test', test)
