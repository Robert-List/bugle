<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % myentities SYSTEM "bugle.ent" >
%myentities;
]>
<chapter id="extending">
    <title>Extending &bugle;</title>

    <sect1 id="extending-introduction">
        <title>Introduction</title>
        <para>
            This chapter is aimed at developers who wish to implement new
            filter-sets for &bugle;. &Bugle; uses a module system to make this
            relatively easy to do without making intrusive changes to the base
            system.
        </para>
        <para>
            It is also worth reading for anyone interested in hacking on the
            &bugle; core.
        </para>
    </sect1>

    <sect1 id="extending-state-api">
        <title>State of the API</title>
        <para>
            At present, there are two ways to distribute plugins for &bugle;.
            The first is as a dynamic shared library (<filename
                class="extension">.so</filename> file), which is copied into
            the plugin directory (<filename
                class="directory">/usr/local/lib/bugle</filename> in a default
            installation). Such a module will work only with the version of
            &bugle; against which it was compiled, and should
            <emphasis>only</emphasis> be done within a binary package
            management system which can ensure that the matching version of
            &bugle; is used.
        </para>
        <warning>
            <para>
                Compiling &bugle; on two machines with the same architecture
                and compiler may still lead to incompatible ABIs, if the
                OpenGL headers differ.
            </para>
        </warning>
        <para>
            The other alternative is as a patch against the &bugle; source
            code (which is also how a custom filter-set is likely to be
            maintained). This form is robust to different versions of
            <filename>GL/glext.h</filename> and may even apply to multiple
            versions of &bugle; if they are not too disparate. This is the
            recommended form of distribution.
        </para>
        <warning>
            <para>
                The API is still changing regularly.
            </para>
        </warning>
        <para>
            A public API, with installed headers and
            <application>pkgconfig</application> support may appear in future.
        </para>
    </sect1>

    <sect1 id="extending-concepts">
        <title>Concepts</title>
        <sect2 id="extending-concepts-hierarchy">
            <title>Callbacks, filter-sets, filters and libraries</title>
            <para>
                The mechanisms for intercepting and modifying OpenGL function
                calls are arranged in a four-level hierarchy. From largest to
                smallest, these are:
            </para>
            <itemizedlist>
                <listitem><para>
                        Filter libraries, which are a loose collection of
                        filter-sets.  These allow filter-sets to be grouped
                        together to avoid having hundreds of files. It also
                        makes shared access to data easier.
                </para></listitem>
                <listitem><para>
                        Filter-sets, which are tightly coupled groups of
                        filters. Each filter-set may have state, may depend
                        upon other filter-sets and may only be loaded or
                        unloaded as a unit.
                </para></listitem>
                <listitem><para>
                        Filters, which are used to control sequencing. For
                        example, some filter-sets need to have some code run
                        before calls are executed and other code after. These
                        pieces of code would be placed in separate filters.
                        The plugin author may list ordering dependencies
                        between filters.
                </para></listitem>
                <listitem><para>
                        Callbacks, which are the actual functions that act on
                        calls. A filter may register multiple callbacks, each
                        of which acts on some subset of the possible calls.
                </para></listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="extending-concepts-groups">
            <title>Functions and groups</title>
            <para>
                In &bugle; terminology, a <firstterm>function</firstterm> is
                simply an OpenGL function. Both
                <function>glActiveTexture</function> and
                <function>glActiveTextureARB</function> are functions, and
                they are referred to by the symbols
                <symbol>FUNC_glActiveTexture</symbol> and
                <symbol>FUNC_glActiveTextureARB</symbol> respectively.
            </para>
            <para>
                At this point, you're probably thinking <quote>but they're
                    the same function!</quote> &Bugle; deals with this using
                <firstterm>groups</firstterm>, which are sets of functions
                with different names but the same signatures and semantics.
                The group that contains these two functions may be referred to
                as either <symbol>GROUP_glActiveTexture</symbol> or
                <symbol>GROUP_glActiveTextureARB</symbol>. The symbols expand
                to the same value.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-guidelines">
        <title>Guidelines</title>
        <para>
            This section contains stylistic guidelines and best practices. You
            should follow them if you hope to get your filter-sets included in
            the &bugle; source code, or want them to be generally useful to
            other users.
        </para>
        <sect2 id="extending-guidelines-style">
            <title>Coding style</title>
            <itemizedlist>
                <listitem><para>Indenting is four spaces</para></listitem>
                <listitem><para>Use spaces not tabs</para></listitem>
                <listitem><para>Both opening and closing braces go on their
                        own line</para></listitem>
                <listitem><para>Function return types go on the same line as
                        the rest of the prototype</para></listitem>
                <listitem><para>Filter-sets, and any other code that will be
                        preloaded into a user program, should link against as
                        few libraries as possible, since if the user program
                        uses a different version there will be conflicts. As a
                        result, C++ code cannot be used if it links against
                        <systemitem class="library">libstdc++</systemitem>.
                </para></listitem>
                <listitem><para>C files should contain conforming C89 syntax as
                        far as possible. That means no variable initialisers,
                        no variable-length arrays, and C++-style
                        <literal>//</literal> comments are not allowed.
                </para></listitem>
                <listitem><para>
                        POSIX, BSD and X/OPEN library functions are
                        acceptable if the appropriate feature macros are
                        defined (<symbol>_POSIX_C_SOURCE</symbol> and so on).
                </para></listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="extending-guidelines-opengl">
            <title>OpenGL extensions</title>
            <para>
                BuGLe tries to support systems that only have header files and
                runtime support for <application>OpenGL</application> 1.1 (so
                that a Win32 port will be possible one day, but also to
                support other systems with old headers).  Thus for any
                functions introduces after 1.1, you should favour the
                <symbol>GROUP_<replaceable>glFunction</replaceable></symbol>
                definition with the oldest name, which is generally an
                extension function. You should also protect any such code with
                a test for the GL extension define e.g.
                <symbol>GL_ARB_multitexture</symbol>.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-api">
        <title>Filter-set API</title>

        <sect2 id="extending-api-libraryinit">
            <title>Library initialisation</title>
            <para>
                Each library must contain an initialisation function with the
                following signature:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_initialise_filter_library(void);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This is the literal name of the function. It will be called by
                &bugle;'s loader code, and you should not mark it as a
                constructor or anything similar.
            </para>
            <para>
                This function does any global initialisation required,
                registers filter-sets, and registers ordering requirements
                between filter-sets:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">#include &lt;src/filters.h&gt;
                    
filter_set *bugle_register_filter_set(filter_set_info *info);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                The <structname>filter_set_info</structname> must be constant and have
                global lifetime, since &bugle; will continue to refer to it
                after the call returns. It has the following fields:
            </para>
            <programlisting language="C">typedef struct
{
    const char *                     name;
    filter_set_loader                load;
    filter_set_unloader              unload;
    filter_set_activator             activate;
    filter_set_deactivator           deactivate;
    const filter_set_variable_info * variables;
    size_t                           call_state_space;
    const char *                     help;
} filter_set_info;</programlisting>
            <para>The fields have the following meanings:</para>
            <variablelist>
                <varlistentry>
                    <term><structfield>name</structfield></term>
                    <listitem><para>
                            The name of the filter-set, as it will appear in
                            <filename>~/.bugle/filters</filename>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>load</structfield></term>
                    <term><structfield>unload</structfield></term>
                    <term><structfield>activate</structfield></term>
                    <term><structfield>deactivate</structfield></term>
                    <listitem><para>
                            Callback functions that are used to load, unload,
                            activate and deactivate the filter-set. They are
                            described in more detail in <xref
                                linkend="extending-api-filtersetinit"/>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>variables</structfield></term>
                    <listitem><para>
                            An array describing the variables that may be
                            configured by the user. This is described in <xref
                                linkend="extending-api-filtersetvariables"/>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>call_state_space</structfield></term>
                    <listitem><para>
                            An amount of space to reserve in the data
                            structure that holds the parameters for each
                            OpenGL function call. This feature is deprecated
                            and should not be used in newly written code; use
                            the object layer instead. You should always set
                            this field to zero.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>help</structfield></term>
                    <listitem><para>
                            A one-line description of the filter-set, which is
                            displayed if an unknown chain is requested by the
                            user.
                    </para></listitem>
                </varlistentry>
            </variablelist>
        </sect2>

        <sect2 id="extending-api-filtersetvariables">
            <title>Filter-set variables</title>
            <para>
                Many filter-sets are configurable via variables that are set
                in the configuration file. The
                <structfield>variables</structfield> field of a
                <structname>filter_set_info</structname> points to an array of
                <structname>filter_set_variable_info</structname> structures,
                which have the following format:
            </para>
            <programlisting language="C">typedef struct
{
    const char *             name;
    const char *             help;
    filter_set_variable_type type;
    void *                   value;
    bool                   (*callback)(const filter_set_variable_info *var, const char *text, const void *value);
} filter_set_info;</programlisting>
            <para>
                The <structfield>name</structfield> and
                <structfield>help</structfield> fields have the same use as
                they do in <structname>filter_set_info</structname>. The
                <structfield>type</structfield> is one of the enumerants in
                <xref linkend="TBL:extending-api-filtersetvariables-types"/>.
            </para>
            <table frame="all" id="TBL:extending-api-filtersetvariables-types">
                <title>Filter-set variable types</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row><entry>Enumerant</entry><entry>C type</entry><entry>Checks</entry></row>
                    </thead>
                    <tbody>
                        <row><entry><symbol>FILTER_SET_VARIABLE_BOOL</symbol></entry><entry><type>bool</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_INT</symbol></entry><entry><type>long</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_UINT</symbol></entry><entry><type>long</type></entry><entry>&ge; 0</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_INT</symbol></entry><entry><type>long</type></entry><entry>&gt; 0</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_FLOAT</symbol></entry><entry><type>float</type></entry><entry>finite</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_STRING</symbol></entry><entry><type>char *</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_KEY</symbol></entry><entry><type>xevent_key</type></entry><entry>valid</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_CUSTOM</symbol></entry><entry>any</entry><entry></entry></row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                With the exception of the
                <symbol>FILTER_SET_VARIABLE_CUSTOM</symbol> custom type, each
                enumerant corresponds to a C type. Set the
                <structfield>value</structfield> field to a pointer to a
                C variable of this type, and it will be overwritten with the
                value specified by the user. The C variable is not modified if
                the user does not specify a value, so it is best to initialise
                the C with an appropriate default value.
            </para>
            <para>
                Sometimes it is necessary to perform some extra validation or
                initialisation when a variable is passed. For example,
                &mp-showstats; accepts the <varname>show</varname> variable
                multiple times to indicate which statistics should be
                displayed. The <structfield>callback</structfield> field may be
                set to a callback function, which is passed a pointer to the
                corresponding
                <structname>filter_set_variable_info</structname> object, the
                raw string present in the configuration file, and a pointer to
                the interpreted value. Note that at the time of the callback,
                the variable passed will <emphasis>not</emphasis> have been
                modified. The callback should return
                <symbol>false</symbol> if the value was invalid and
                <symbol>true</symbol> otherwise.
            </para>
        </sect2>

        <sect2 id="extending-api-filtersetinit">
            <title>Filter-set initialisation and destruction</title>
            <para>
                Foo
            </para>
        </sect2>

        <sect2 id="extending-api-callbacks">
            <title>Writing callbacks</title>
            <para>
                Foo
            </para>
        </sect2>
    </sect1>
</chapter>
