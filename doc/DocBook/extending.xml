<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % myentities SYSTEM "bugle.ent" >
%myentities;
]>
<chapter id="extending">
    <title>Extending &bugle;</title>

    <sect1 id="extending-introduction">
        <title>Introduction</title>
        <para>
            This chapter is aimed at developers who wish to implement new
            filter-sets for &bugle;. &Bugle; uses a module system to make this
            relatively easy to do without making intrusive changes to the base
            system.
        </para>
        <para>
            It is also worth reading for anyone interested in hacking on the
            &bugle; core.
        </para>
    </sect1>

    <sect1 id="extending-state-api">
        <title>State of the API</title>
        <para>
            At present, there are two ways to distribute plugins for &bugle;.
            The first is as a dynamic shared library (<filename
                class="extension">.so</filename> file), which is copied into
            the plugin directory (<filename
                class="directory">/usr/local/lib/bugle</filename> in a default
            installation). Such a module will work only with the version of
            &bugle; against which it was compiled, and should
            <emphasis>only</emphasis> be done within a binary package
            management system which can ensure that the matching version of
            &bugle; is used.
        </para>
        <warning>
            <para>
                Compiling &bugle; on two machines with the same architecture
                and compiler may still lead to incompatible ABIs, if the
                OpenGL headers differ.
            </para>
        </warning>
        <para>
            The other alternative is as a patch against the &bugle; source
            code (which is also how a custom filter-set is likely to be
            maintained). This form is robust to different versions of
            <filename>GL/glext.h</filename> and may even apply to multiple
            versions of &bugle; if they are not too disparate. This is the
            recommended form of distribution.
        </para>
        <warning>
            <para>
                The API is still changing regularly.
            </para>
        </warning>
        <para>
            A public API, with installed headers and
            <application>pkgconfig</application> support may appear in future.
        </para>
    </sect1>

    <sect1 id="extending-guidelines">
        <title>Guidelines</title>
        <para>
            This section contains stylistic guidelines and best practices. You
            should follow them if you hope to get your filter-sets included in
            the &bugle; source code, or want them to be generally useful to
            other users.
        </para>
        <sect2 id="extending-guidelines-style">
            <title>Coding style</title>
            <itemizedlist>
                <listitem><para>Indenting is four spaces.</para></listitem>
                <listitem><para>Use spaces not tabs.</para></listitem>
                <listitem><para>Both opening and closing braces go on their
                        own line.</para></listitem>
                <listitem><para>Function return types go on the same line as
                        the rest of the prototype.</para></listitem>
                <listitem><para>Filter-sets, and any other code that will be
                        preloaded into a user program, should link against as
                        few libraries as possible, since if the user program
                        uses a different version there will be conflicts. As a
                        result, C++ code cannot be used if it links against
                        <systemitem class="library">libstdc++</systemitem>.
                </para></listitem>
                <listitem><para>Functions that act on
                        <replaceable>type</replaceable> should be named
                        <function><replaceable>type</replaceable>_<replaceable>action</replaceable></function>.
                        See below for when to prefix the name with
                        <literal>bugle_</literal>.
                </para></listitem>
                <listitem><para>Names of types should generally not have a
                        <literal>bugle_</literal> prefix, unless it is needed
                        to clearly disambiguate it.
                </para></listitem>
                <listitem><para>Functions in the core code should have a
                        <literal>bugle_</literal> prefix if and only if they
                        are meant to be called from filter-sets or from the
                        debugger. Such functions are generally safe for
                        filter-sets to use unless marked otherwise.
                </para></listitem>
                <listitem><para>
                        Functions in filter-sets should be declared <code
                            language="C">static</code>, unless they are to be
                        exported to other filter-sets. These functions must
                        have some vendor prefix. This is
                        <literal>bugle_</literal> for the filter-sets
                        distributed with &bugle;, but should be something else
                        for other filter-sets to avoid conflicts.
                </para></listitem>
                <listitem><para>C files should contain conforming C89 syntax as
                        far as possible. That means no variable initialisers,
                        no variable-length arrays, and no C++-style
                        (<literal>//</literal>) comments.
                </para></listitem>
                <listitem><para>
                        POSIX, BSD and X/OPEN library functions are
                        acceptable if the appropriate feature macros are
                        defined (<symbol>_POSIX_C_SOURCE</symbol> and so on).
                        GNU-specific library functions should be avoided or
                        abstracted (like <function>bugle_asprintf</function>).
                </para></listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="extending-guidelines-opengl">
            <title>OpenGL extensions</title>
            <para>
                BuGLe tries to support systems that only have header files and
                runtime support for <application>OpenGL</application> 1.1 (so
                that a Win32 port will be possible one day, but also to
                support other systems with old headers).  Thus for any
                functions introduces after 1.1, you should favour the
                <symbol>GROUP_<replaceable>glFunction</replaceable></symbol>
                definition with the oldest name, which is generally an
                extension function. You should also protect any such code with
                a test for the GL extension define e.g.
                <symbol>GL_ARB_multitexture</symbol>.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-concepts">
        <title>Concepts</title>
        <sect2 id="extending-concepts-hierarchy">
            <title>Callbacks, filter-sets, filters and libraries</title>
            <para>
                The mechanisms for intercepting and modifying OpenGL function
                calls are arranged in a four-level hierarchy. From largest to
                smallest, these are:
            </para>
            <itemizedlist>
                <listitem><para>
                        Filter libraries, which are a loose collection of
                        filter-sets.  These allow filter-sets to be grouped
                        together to avoid having hundreds of files. It also
                        makes shared access to data easier.
                </para></listitem>
                <listitem><para>
                        Filter-sets, which are tightly coupled groups of
                        filters. Each filter-set may have state, may depend
                        upon other filter-sets and may only be loaded or
                        unloaded as a unit.
                </para></listitem>
                <listitem><para>
                        Filters, which are used to control sequencing. For
                        example, some filter-sets need to have some code run
                        before calls are executed and other code after. These
                        pieces of code would be placed in separate filters.
                        The plugin author may list ordering dependencies
                        between filters.
                </para></listitem>
                <listitem><para>
                        Callbacks, which are the actual functions that act on
                        calls. A filter may register multiple callbacks, each
                        of which acts on some subset of the possible calls.
                </para></listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="extending-concepts-load-activate">
            <title>Loading and activation</title>
            <para>
                In order to allow modifiers to be turned on or off on the fly,
                there is a distinction between loading and activation. All
                filter-sets listed in the chain are loaded, but should alter
                the behaviour of the program only when active. Filter-sets are
                loaded only at startup and unloaded at program termination,
                but can be activated or deactivated arbitrarily. Most
                callbacks are only called when the filter-set is active, but
                it is possible to register callbacks that are called even when
                the filter-set is inactive. This allows the filter-set to
                monitor state so that it can do the right thing during
                activation, or to execute cleanup code after deactivation.
            </para>
        </sect2>
        <sect2 id="extending-concepts-groups">
            <title>Functions and groups</title>
            <para>
                In &bugle; terminology, a <firstterm>function</firstterm> is
                simply an OpenGL function. Both
                <function>glActiveTexture</function> and
                <function>glActiveTextureARB</function> are functions, and
                they are referred to by the symbols
                <symbol>FUNC_glActiveTexture</symbol> and
                <symbol>FUNC_glActiveTextureARB</symbol> respectively.
            </para>
            <para>
                At this point, you're probably thinking <quote>but they're
                    the same function!</quote> &Bugle; deals with this using
                <firstterm>groups</firstterm>, which are sets of functions
                with different names but the same signatures and semantics.
                The group that contains these two functions may be referred to
                as either <symbol>GROUP_glActiveTexture</symbol> or
                <symbol>GROUP_glActiveTextureARB</symbol>. The symbols expand
                to the same value.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-api">
        <title>Filter-set API</title>

        <sect2 id="extending-api-libraryinit">
            <title>Library initialisation</title>
            <para>
                Each library must contain an initialisation function with the
                following signature:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_initialise_filter_library(void);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This is the literal name of the function. It will be called by
                &bugle;'s loader code, and you should not mark it as a
                constructor or anything similar. Note that it will always be
                called, even if the corresponding filter-sets are not
                requested by the user.
            </para>
            <para>
                This function does any global initialisation required,
                registers filter-sets, and registers ordering requirements
                between filter-sets:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">#include &lt;src/filters.h&gt;
                    
filter_set *bugle_filter_set_register(filter_set_info *info);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                The <structname>filter_set_info</structname> must be constant and have
                global lifetime, since &bugle; will continue to refer to it
                after the call returns. It has the following fields:
            </para>
            <programlisting language="C">typedef struct
{
    const char *                     name;
    filter_set_loader                load;
    filter_set_unloader              unload;
    filter_set_activator             activate;
    filter_set_deactivator           deactivate;
    const filter_set_variable_info * variables;
    const char *                     help;
} filter_set_info;</programlisting>
            <para>The fields have the following meanings:</para>
            <variablelist>
                <varlistentry>
                    <term><structfield>name</structfield></term>
                    <listitem><para>
                            The name of the filter-set, as it will appear in
                            <filename>~/.bugle/filters</filename>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>load</structfield></term>
                    <term><structfield>unload</structfield></term>
                    <term><structfield>activate</structfield></term>
                    <term><structfield>deactivate</structfield></term>
                    <listitem><para>
                            Callback functions that are used to load, unload,
                            activate and deactivate the filter-set. They are
                            described in more detail in <xref
                                linkend="extending-api-filtersetinit"/>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>variables</structfield></term>
                    <listitem><para>
                            An array describing the variables that may be
                            configured by the user. This is described in <xref
                                linkend="extending-api-filtersetvariables"/>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>help</structfield></term>
                    <listitem><para>
                            A one-line description of the filter-set, which is
                            displayed if an unknown chain is requested by the
                            user.
                    </para></listitem>
                </varlistentry>
            </variablelist>
        </sect2>

        <sect2 id="extending-api-filtersetvariables">
            <title>Filter-set variables</title>
            <para>
                Many filter-sets are configurable via variables that are set
                in the configuration file. The
                <structfield>variables</structfield> field of a
                <structname>filter_set_info</structname> points to an array of
                <structname>filter_set_variable_info</structname> structures,
                which have the following format:
            </para>
            <programlisting language="C">typedef struct
{
    const char *             name;
    const char *             help;
    filter_set_variable_type type;
    void *                   value;
    bool                   (*callback)(const filter_set_variable_info *var, const char *text, const void *value);
} filter_set_info;</programlisting>
            <para>
                The <structfield>name</structfield> and
                <structfield>help</structfield> fields have the same use as
                they do in <structname>filter_set_info</structname>. The
                <structfield>type</structfield> is one of the enumerants in
                <xref linkend="TBL:extending-api-filtersetvariables-types"/>.
            </para>
            <table frame="all" id="TBL:extending-api-filtersetvariables-types">
                <title>Filter-set variable types</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row><entry>Enumerant</entry><entry>C type</entry><entry>Checks</entry></row>
                    </thead>
                    <tbody>
                        <row><entry><symbol>FILTER_SET_VARIABLE_BOOL</symbol></entry><entry><type>bool</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_INT</symbol></entry><entry><type>long</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_UINT</symbol></entry><entry><type>long</type></entry><entry>&ge; 0</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_INT</symbol></entry><entry><type>long</type></entry><entry>&gt; 0</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_FLOAT</symbol></entry><entry><type>float</type></entry><entry>finite</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_STRING</symbol></entry><entry><type>char *</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_KEY</symbol></entry><entry><type>xevent_key</type></entry><entry>valid</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_CUSTOM</symbol></entry><entry>any</entry><entry></entry></row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                With the exception of the
                <symbol>FILTER_SET_VARIABLE_CUSTOM</symbol> custom type, each
                enumerant corresponds to a C type. Set the
                <structfield>value</structfield> field to a pointer to a
                C variable of this type, and it will be overwritten with the
                value specified by the user. The C variable is not modified if
                the user does not specify a value, so it is best to initialise
                the C with an appropriate default value.
            </para>
            <para>
                Sometimes it is necessary to perform some extra validation or
                initialisation when a variable is passed. For example,
                &mp-showstats; accepts the <varname>show</varname> variable
                multiple times to indicate which statistics should be
                displayed. The <structfield>callback</structfield> field may be
                set to a callback function, which is passed a pointer to the
                corresponding
                <structname>filter_set_variable_info</structname> object, the
                raw string present in the configuration file, and a pointer to
                the interpreted value. Note that at the time of the callback,
                the variable passed will <emphasis>not</emphasis> have been
                modified. The callback should return
                <symbol>false</symbol> if the value was invalid and
                <symbol>true</symbol> otherwise.
            </para>
        </sect2>

        <sect2 id="extending-api-filtersetinit">
            <title>Filter-set initialisation and destruction</title>
            <para>
                Apart from initialising internal structures, a filter-set
                loader registers filters and callbacks. The function to
                register a filter within a filter-set is
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">filter * bugle_filter_register(filter_set *handle, const char *name);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                A <type>filter *</type> is an opaque handle to a filter. It is
                passed to the following functions to register callbacks:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_filter_catches(filter *f, budgie_group group, bool inactive, filter_callback callback);
void bugle_filter_catches_function(filter *f, budgie_function function, bool inactive, filter_callback callback);
void bugle_filter_catches_all(filter *f, bool inactive, filter_callback callback);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                These respectively register callbacks for a single group, a
                single function, or all functions. The
                <parameter>inactive</parameter> says whether the callback
                should apply when the filter-set is inactive. Usually you will
                want to set this to <symbol>false</symbol>, but in some cases
                it is necessary to track some state even when the filter-set
                is inactive.
            </para>
        </sect2>

        <sect2 id="extending-api-callbacks">
            <title>Writing callbacks</title>
            <para>
                In the functions above, <parameter>callback</parameter> is a
                function with the signature
            </para>
            <funcsynopsis>
                <funcsynopsisinfo>bool callback(function_call *call, const callback_data *data);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                The callback should generally return <symbol>true</symbol>.
                Returning <symbol>false</symbol>
                aborts any further processing of the call (including
                execution if the <systemitem>invoke</systemitem> filter has not yet run). This can
                be useful if you want to suppress a call, but if possible
                it is better to allow execution and undo the effects
                afterwards so that later filters get a chance to run.
            </para>
            <para> Callbacks that handle multiple OpenGL functions will need
                to know which function was called; the function is found in
                <code language="cpp">call->generic.id</code>, but more useful
                is the group found in <code
                    language="cpp">call->generic.group</code>. One can also
                get access to the arguments: if the call is known to be
                <function>gl<replaceable>Function</replaceable></function>,
                then <code
                    language="cpp">*call->typed.gl<replaceable>Function</replaceable>.arg<replaceable>i</replaceable></code>
                is the <replaceable>i</replaceable>th argument, and <code
                    language="cpp">*call->typed.gl<replaceable>Function</replaceable>.retn</code>
                is the return value. If the function is not known at compile
                time, then the arguments can be accessed via the
                <type>void</type> pointers <code
                    language="cpp">call->generic.args<replaceable>[i</replaceable>]</code>
                and <code language="cpp">call->generic.retn</code>. These
                values can also be modified to change the arguments used or
                the value returned to the application, respectively.
            </para>
            <para>
                The <parameter>data</parameter> is currently still undergoing
                revision, so it will not be documented yet.
            </para>
        </sect2>

        <sect2 id="extending-api-utilities">
            <title>Utility functions and filter-sets</title>
            <para>Foo
            </para>
        </sect2>
    </sect1>
</chapter>
