<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % myentities SYSTEM "bugle.ent" >
%myentities;
]>
<chapter id="extending">
    <title>Extending &bugle;</title>

    <sect1 id="extending-introduction">
        <title>Introduction</title>
        <para>
            This chapter is aimed at developers who wish to implement new
            filter-sets for &bugle;. &Bugle; uses a module system to make this
            relatively easy to do without making intrusive changes to the base
            system.
        </para>
        <para>
            It is also worth reading for anyone interested in hacking on the
            &bugle; core.
        </para>
    </sect1>

    <sect1 id="extending-state-api">
        <title>State of the API</title>
        <para>
            The API has recently undergone a lot of cleaning up to make it,
            as far as possible, independent of the particular OpenGL
            headers used to compile &bugle;. If an external filter-set is
            compiled with a more complete set of OpenGL extensions, then
            things should continue to work provided that the filter-set
            gracefully handles missing functionality. If &bugle; was compiled
            with the more complete set of extensions, then things should work
            regardless.
        </para>
        <para>
            That is all in theory, but it has yet to be put to the test. There
            will probably be some breakages, but hopefully not too often, or
            every time a new OpenGL extension is published.
        </para>
        <warning>
            <para>
                The API is still changing regularly.
            </para>
        </warning>
    </sect1>

    <sect1 id="extending-guidelines">
        <title>Guidelines</title>
        <para>
            This section contains stylistic guidelines and best practices. You
            should follow them if you hope to get your filter-sets included in
            the &bugle; source code, or want them to be generally useful to
            other users.
        </para>
        <sect2 id="extending-guidelines-style">
            <title>Coding style</title>
            <itemizedlist>
                <listitem><para>Indenting is four spaces.</para></listitem>
                <listitem><para>Use spaces not tabs.</para></listitem>
                <listitem><para>Both opening and closing braces go on their
                        own line.</para></listitem>
                <listitem><para>Function return types go on the same line as
                        the rest of the prototype.</para></listitem>
                <listitem><para>Filter-sets, and any other code that will be
                        preloaded into a user program, should link against as
                        few libraries as possible, since if the user program
                        uses a different version there will be conflicts. As a
                        result, C++ code cannot be used if it links against
                        <systemitem class="library">libstdc++</systemitem>.
                </para></listitem>
                <listitem><para>Functions that act on
                        <replaceable>type</replaceable> should be named
                        <function><replaceable>type</replaceable>_<replaceable>action</replaceable></function>.
                        See below for when to prefix the name with
                        <literal>bugle_</literal>.
                </para></listitem>
                <listitem><para>Names of types should generally not have a
                        <literal>bugle_</literal> prefix, unless it is needed
                        to clearly disambiguate it.
                </para></listitem>
                <listitem><para>Functions in the core code should have a
                        <literal>bugle_</literal> prefix if and only if they
                        are meant to be called from filter-sets or from the
                        debugger. Such functions are generally safe for
                        filter-sets to use unless marked otherwise.
                </para></listitem>
                <listitem><para>A constructor for a type that returns a
                        <function>malloc</function>ed instance should be named
                        <function><replaceable>type</replaceable>_new</function>,
                        whereas a constructor that modifies existing memory is
                        called
                        <function><replaceable>type</replaceable>_init</function>.
                        The corresponding destructors are
                        <function><replaceable>type</replaceable>_free</function>
                        and
                        <function><replaceable>type</replaceable>_clear</function>.
                        For a module of code, initialisation and shutdown
                        functions should be named
                        <function><replaceable>module</replaceable>_initialise</function>
                        (note spelling) and 
                        <function><replaceable>module</replaceable>_shutdown</function>.
                        This in particular applies to filter-sets.
                </para></listitem>
                <listitem><para>
                        Functions in filter-sets should be declared <code
                            language="C">static</code>, unless they are to be
                        exported to other filter-sets. These functions must
                        have some vendor prefix. This is
                        <literal>bugle_</literal> for the filter-sets
                        distributed with &bugle;, but should be something else
                        for other filter-sets to avoid conflicts.
                </para></listitem>
                <listitem><para>C files should contain conforming C89 syntax as
                        far as possible. That means no variable initialisers,
                        no variable-length arrays, and no C++-style
                        (<literal>//</literal>) comments.
                </para></listitem>
                <listitem><para>
                        POSIX, BSD and X/OPEN library functions are
                        acceptable if the appropriate feature macros are
                        defined (<symbol>_POSIX_C_SOURCE</symbol> and so on).
                        For filter-sets distributed with &bugle;,
                        gnulib should be used for memory-allocating functions
                        (<function>xmalloc</function> and
                        <function>xasprintf</function>, for example) and for
                        non-portable functions. Unfortunately, gnulib symbols
                        cannot be exported since they may conflict with
                        different implementations in the debugged application.
                </para></listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="extending-guidelines-oglcontexts">
            <title>OpenGL contexts and threads</title>
            <para>
                Most of the state in OpenGL is associated with a particular
                <firstterm>context</firstterm>. Each thread may have a
                different current context, or no context. Each context can be
                current in at most one thread. You should keep this in mind
                when you attempt to track any particular OpenGL state. If you
                are using a global variable then your code is almost certainly
                not current for multi-threaded or multi-context applications.
            </para>
            <para>
                The <link linkend="extending-objects">object sub-system</link>
                in &bugle; makes it easy to associate data with a particular
                context, and is the recommended method.
            </para>
        </sect2>
        <sect2 id="extending-guidelines-oglextensions">
            <title>OpenGL extensions</title>
            <para>
                BuGLe tries to support systems that only have header files and
                runtime support for <application>OpenGL</application> 1.1 (so
                that a Win32 port will be possible one day, but also to
                support other systems with old headers).  Thus for any
                functions introduces after 1.1, you should favour the
                <symbol>GROUP_<replaceable>glFunction</replaceable></symbol>
                definition with the oldest name, which is generally an
                extension function. You should also protect any such code with
                a test for the GL extension define e.g.,
                <symbol>GL_ARB_multitexture</symbol>.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-concepts">
        <title>Concepts</title>
        <sect2 id="extending-concepts-hierarchy">
            <title>Callbacks, filter-sets, filters and libraries</title>
            <para>
                The mechanisms for intercepting and modifying OpenGL function
                calls are arranged in a four-level hierarchy. From largest to
                smallest, these are:
            </para>
            <itemizedlist>
                <listitem><para>
                        Filter libraries, which are a loose collection of
                        filter-sets.  These allow filter-sets to be grouped
                        together to avoid having hundreds of files. It also
                        makes shared access to data easier.
                </para></listitem>
                <listitem><para>
                        Filter-sets, which are tightly coupled groups of
                        filters. Each filter-set may have state, may depend
                        upon other filter-sets and may only be loaded or
                        unloaded as a unit.
                </para></listitem>
                <listitem><para>
                        Filters, which are used to control sequencing. For
                        example, some filter-sets need to have some code run
                        before calls are executed and other code after. These
                        pieces of code would be placed in separate filters.
                        The plugin author may list ordering dependencies
                        between filters.
                </para></listitem>
                <listitem><para>
                        Callbacks, which are the actual functions that act on
                        calls. A filter may register multiple callbacks, each
                        of which acts on some subset of the possible calls.
                </para></listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="extending-concepts-load-activate">
            <title>Loading and activation</title>
            <para>
                In order to allow modifiers to be turned on or off on the fly,
                there is a distinction between loading and activation. All
                filter-sets listed in the chain are loaded, but should alter
                the behaviour of the program only when active. Filter-sets are
                loaded only at startup and unloaded at program termination,
                but can be activated or deactivated arbitrarily. Most
                callbacks are only called when the filter-set is active, but
                it is possible to register callbacks that are called even when
                the filter-set is inactive. This allows the filter-set to
                monitor state so that it can do the right thing during
                activation, or to execute cleanup code after deactivation.
            </para>
        </sect2>
        <sect2 id="extending-concepts-budgie">
            <title>Budgie</title>
            <para>
                Budgie is the module within &bugle; that generates huge wads
                of code automatically. Apart from the code to override each
                OpenGL function, it also generates a lot of reflection
                information about functions and types. The API for the
                generated code isn't currently documented. Refer to existing
                filter-sets or to the header files in <filename
                    class="directory">include/budgie</filename>.
            </para>
        </sect2>
        <sect2 id="extending-concepts-groups">
            <title>Functions and groups</title>
            <para>
                In &bugle; terminology, a <firstterm>function</firstterm> is
                simply an OpenGL function. Both
                <function>glActiveTexture</function> and
                <function>glActiveTextureARB</function> are functions, and
                they are referred to by the symbols
                <symbol>FUNC_glActiveTexture</symbol> and
                <symbol>FUNC_glActiveTextureARB</symbol> respectively.
            </para>
            <para>
                At this point, you're probably thinking <quote>but they're
                    the same function!</quote> &Bugle; deals with this using
                <firstterm>groups</firstterm>, which are sets of functions
                with different names but the same signatures and semantics.
                The group that contains these two functions may be referred to
                as either <symbol>GROUP_glActiveTexture</symbol> or
                <symbol>GROUP_glActiveTextureARB</symbol>. The symbols expand
                to the same value.
            </para>
            <para>
                The values of these symbols can change every time the OpenGL
                headers are modified, so the symbols should not be used in
                filter-sets (in fact, the corresponding headers are no even
                installed by &bugle;). Instead, you should use
                <function>budgie_function_name</function>,
                <function>budgie_function_id</function> and
                <function>budgie_function_group</function> to map between
                these numbers and symbolic names on the fly.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-api">
        <title>Basic filter-set API</title>

        <sect2 id="extending-api-libraryinit">
            <title>Library initialisation</title>
            <para>
                Each library must contain an initialisation function with the
                following signature:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_initialise_filter_library(void);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This is the literal name of the function. It will be called by
                &bugle;'s loader code, and you should not mark it as a
                constructor or anything similar. Note that it will always be
                called, even if the corresponding filter-sets are not
                requested by the user.
            </para>
            <para>
                This function does any global initialisation required,
                registers filter-sets, and registers ordering requirements
                between filter-sets:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">#include &lt;src/filters.h&gt;
                    
filter_set *bugle_filter_set_new(filter_set_info *info);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                The <structname>filter_set_info</structname> must be constant and have
                global lifetime, since &bugle; will continue to refer to it
                after the call returns. It has the following fields:
            </para>
            <programlisting language="C">typedef struct
{
    const char *                     name;
    filter_set_loader                load;
    filter_set_unloader              unload;
    filter_set_activator             activate;
    filter_set_deactivator           deactivate;
    const filter_set_variable_info * variables;
    const char *                     help;
} filter_set_info;</programlisting>
            <para>The fields have the following meanings:</para>
            <variablelist>
                <varlistentry>
                    <term><structfield>name</structfield></term>
                    <listitem><para>
                            The name of the filter-set, as it will appear in
                            <filename>~/.bugle/filters</filename>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>load</structfield></term>
                    <term><structfield>unload</structfield></term>
                    <term><structfield>activate</structfield></term>
                    <term><structfield>deactivate</structfield></term>
                    <listitem><para>
                            Callback functions that are used to load, unload,
                            activate and deactivate the filter-set. They are
                            described in more detail in <xref
                                linkend="extending-api-filtersetinit"/>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>variables</structfield></term>
                    <listitem><para>
                            An array describing the variables that may be
                            configured by the user. This is described in <xref
                                linkend="extending-api-filtersetvariables"/>.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>help</structfield></term>
                    <listitem><para>
                            A one-line description of the filter-set, which is
                            displayed if an unknown chain is requested by the
                            user.
                    </para></listitem>
                </varlistentry>
            </variablelist>
        </sect2>

        <sect2 id="extending-api-filtersetvariables">
            <title>Filter-set variables</title>
            <para>
                Many filter-sets are configurable via variables that are set
                in the configuration file. The
                <structfield>variables</structfield> field of a
                <structname>filter_set_info</structname> points to an array of
                <structname>filter_set_variable_info</structname> structures,
                which have the following format:
            </para>
            <programlisting language="C">typedef struct
{
    const char *             name;
    const char *             help;
    filter_set_variable_type type;
    void *                   value;
    bool                   (*callback)(const filter_set_variable_info *var, const char *text, const void *value);
} filter_set_info;</programlisting>
            <para>
                The <structfield>name</structfield> and
                <structfield>help</structfield> fields have the same use as
                they do in <structname>filter_set_info</structname>. The
                <structfield>type</structfield> is one of the enumerants in
                <xref linkend="TBL:extending-api-filtersetvariables-types"/>.
            </para>
            <table frame="all" id="TBL:extending-api-filtersetvariables-types">
                <title>Filter-set variable types</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row><entry>Enumerant</entry><entry>C type</entry><entry>Checks</entry></row>
                    </thead>
                    <tbody>
                        <row><entry><symbol>FILTER_SET_VARIABLE_BOOL</symbol></entry><entry><type>bool</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_INT</symbol></entry><entry><type>long</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_UINT</symbol></entry><entry><type>long</type></entry><entry>&ge; 0</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_INT</symbol></entry><entry><type>long</type></entry><entry>&gt; 0</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_FLOAT</symbol></entry><entry><type>float</type></entry><entry>finite</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_STRING</symbol></entry><entry><type>char *</type></entry><entry></entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_KEY</symbol></entry><entry><type>xevent_key</type></entry><entry>valid</entry></row>
                        <row><entry><symbol>FILTER_SET_VARIABLE_CUSTOM</symbol></entry><entry>any</entry><entry></entry></row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                With the exception of the
                <symbol>FILTER_SET_VARIABLE_CUSTOM</symbol> custom type, each
                enumerant corresponds to a C type. Set the
                <structfield>value</structfield> field to a pointer to a
                C variable of this type, and it will be overwritten with the
                value specified by the user. The C variable is not modified if
                the user does not specify a value, so it is best to initialise
                the C with an appropriate default value.
            </para>
            <para>
                Sometimes it is necessary to perform some extra validation or
                initialisation when a variable is passed. For example,
                &mp-showstats; accepts the <varname>show</varname> variable
                multiple times to indicate which statistics should be
                displayed. The <structfield>callback</structfield> field may be
                set to a callback function, which is passed a pointer to the
                corresponding
                <structname>filter_set_variable_info</structname> object, the
                raw string present in the configuration file, and a pointer to
                the interpreted value. Note that at the time of the callback,
                the variable passed will <emphasis>not</emphasis> have been
                modified. The callback should return
                <symbol>false</symbol> if the value was invalid and
                <symbol>true</symbol> otherwise.
            </para>
        </sect2>

        <sect2 id="extending-api-filtersetinit">
            <title>Filter-set initialisation and destruction</title>
            <para>
                Apart from initialising internal structures, a filter-set
                loader registers filters and callbacks. The function to
                register a filter within a filter-set is
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">filter * bugle_filter_new(filter_set *handle, const char *name);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                A <type>filter *</type> is an opaque handle to a filter. It is
                passed to the following functions to register callbacks:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_filter_catches(filter *f, const char *group, bool inactive, filter_callback callback);
void bugle_filter_catches_function(filter *f, const char *function, bool inactive, filter_callback callback);
void bugle_filter_catches_all(filter *f, bool inactive, filter_callback callback);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                These respectively register callbacks for a single group, a
                single function, or all functions. The
                <parameter>inactive</parameter> says whether the callback
                should apply when the filter-set is inactive. Usually you will
                want to set this to <symbol>false</symbol>, but in some cases
                it is necessary to track some state even when the filter-set
                is inactive. When using a group, you can use the name of any
                function in that group, although it is best to use the one
                with the oldest name as &bugle; is most likely to know about
                it. If &bugle; was compiled without OpenGL headers exposing
                that function, it is ignored.
            </para>
            <para>
                A filter-set should also indicate ordering dependencies
                between filters. This is done by calling
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_filter_order(const char *first, const char *second);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This does not require that either filter is actually loaded.
                It simply indicates that if both are present, then they are to
                be run in the specified order. The most common use is to
                specify an ordering relative to
                <systemitem>invoke</systemitem>, the filter that is
                responsible for passing a function call on to the real OpenGL
                library.
            </para>
        </sect2>

        <sect2 id="extending-api-callbacks">
            <title>Writing callbacks</title>
            <para>
                In the functions above, <parameter>callback</parameter> is a
                function with the signature
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">bool callback(function_call *call, const callback_data *data);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                The callback should generally return <symbol>true</symbol>.
                Returning <symbol>false</symbol>
                aborts any further processing of the call (including
                execution if the <systemitem>invoke</systemitem> filter has not yet run). This can
                be useful if you want to suppress a call, but if possible
                it is better to allow execution and undo the effects
                afterwards so that later filters get a chance to run.
            </para>
            <para> Callbacks that handle multiple OpenGL functions will need
                to know which function was called; the function is found in
                <code language="cpp">call->generic.id</code>, but more useful
                is the group found in <code
                    language="cpp">call->generic.group</code>. One can also
                get access to the arguments: if the call is known to be
                <function>gl<replaceable>Function</replaceable></function>,
                then <code
                    language="cpp">*call->typed.gl<replaceable>Function</replaceable>.arg<replaceable>i</replaceable></code>
                is the <replaceable>i</replaceable>th argument, and <code
                    language="cpp">*call->typed.gl<replaceable>Function</replaceable>.retn</code>
                is the return value. If the function is not known at compile
                time, then the arguments can be accessed via the
                <type>void</type> pointers <code
                    language="cpp">call->generic.args<replaceable>[i</replaceable>]</code>
                and <code language="cpp">call->generic.retn</code>. These
                values can also be modified to change the arguments used or
                the value returned to the application, respectively.
            </para>
            <para>
                The <parameter>data</parameter> is currently still undergoing
                revision, so it will not be documented yet.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-objects">
        <title>Object shadowing</title>
        <para>
            &Bugle; has support for associating data with OpenGL objects such
            as contexts, textures, calls and so on. It is implemented using a
            generic interface that is not OpenGL-specific, and utility code to
            deal with specific types of objects is implemented on top of this.
        </para>
        <sect2 id="extending-objects-concepts">
            <title>Concepts</title>
            <variablelist>
                <varlistentry>
                    <term>class (<type>object_class</type>)</term>
                    <listitem><para>
                            A class is like an OOP class, in that
                            objects are instantiations of classes with data.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>registrant</term>
                    <listitem><para>
                            Several units of code may wish to attach storage
                            to an object, and they need to be kept separate
                            from each other. Each such unit is known as a
                            registrant. There is no explicit structure to
                            represent registrants: it's just a piece of
                            terminology for the documentation.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>object (<type>object *</type>)</term>
                    <listitem><para>
                            An <firstterm>object</firstterm> holds all the
                            data that all registrants have attached to a
                            single OpenGL object. It should be treated as
                            being opaque.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>view (<type>object_view</type>)</term>
                    <listitem>
                        <para>
                            This term is somewhat ambiguous. The
                            <type>object_view</type> type is a key used to
                            fetch a particular registrant's data from objects
                            of a particular class. In some places, however, it
                            also means the actual data that is stored in the
                            object.
                        </para>
                        <para>
                            Each registrant is free to define these data in
                            any way it likes. The memory will be suitably
                            aligned for all built-in data types (at present
                            the memory is allocated with
                            <function>malloc</function>, but this may well
                            change for efficiency reasons).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>scope</term>
                    <listitem><para>
                            This has nothing to do with inheritence. It refers
                            to the scope at which an object can be considered
                            to be <firstterm>current</firstterm>. For example,
                            each thread has a current context, and each
                            context may have a current display list, so
                            display lists have context scope. &Bugle; allows
                            you so specify what the current object for each
                            class is (which may be <symbol>NULL</symbol>), and
                            retrieve it later.
                    </para></listitem>
                </varlistentry>
            </variablelist>
        </sect2>
        <sect2 id="extending-objects-classes">
            <title>Class management functions</title>
            <para>
                Class structs are generally declared as global pointers with
                external linkage, so that code that uses them may access them
                directly.
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">#include "src/objects.h"
                    
object_class *bugle_object_class_new(object_class *parent);
void bugle_object_class_free(object_class *klass);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                These are the constructor and destructor for classes. The
                <parameter>parent</parameter> is either the class defining the scope of
                the new class, or <symbol>NULL</symbol> to indicate that the
                new class has thread scope (like an OpenGL context).
            </para>
            <warning>
                <para>
                    The <function>bugle_object_class_free</function> function
                    does not delete instances of the class. They must be
                    manually deleted first. Attempting to manipulate objects
                    once their class (or any ancestor class in the scope tree)
                    has been deleted will lead to undefined behaviour.
                </para>
            </warning>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">object_view bugle_object_view_new(object_class *klass, 
                                       void (*constructor)(const void *, void *), 
                                       void (*destructor)(void *), 
                                       size_t size)</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This function creates a new view on an existing class. The
                constructor is described later. The destructor is simply
                called when the object goes away, and receives a pointer to
                the view data. It is responsible for cleaning up, but it must
                <emphasis>not</emphasis> attempt to <function>free</function>
                the pointer.
            </para>
            <para>
                The <parameter>size</parameter> is the number of
                bytes that the registrant wishes to associate with each
                instance of this class. It is legal for the size to be zero,
                in which case no data is associated but the constructor and
                destructor will still be called to provide notification of
                object creation and destruction.
            </para>
        </sect2>
        <sect2 id="extending-objects-objects">
            <title>Object management functions</title>
            <para>
                Since the object system has no knowledge of OpenGL, each type
                of object requires some management code to shadow creation and
                destruction of OpenGL objects, and to keep track of which
                object is current.
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">object *bugle_object_new(object_class *klass, const void *key, bool make_current);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This instantiates a new instance of the given class.
                Instantiate an instance of the given class. Firstly, if
                <parameter>make_current</parameter> is <symbol>true</symbol>
                then the new object is immediately made the current object of
                its class. Then, for each registrant the constructor is called
                to initialise the data in its view. The constructor is passed
                <parameter>key</parameter> and the view data (the
                <parameter>key</parameter> parameter exists
                only to pass extra information to the constructor, usually
                about the associated GL object). Before calling the
                constructor, the view data is filled with zero bytes. The
                constructor is optional and may be <symbol>NULL</symbol>.
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void bugle_object_free(object *obj);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                For each registrant of the class, calls the destructor (if
                any), passing a pointer to the view data.  It then frees the
                memory associated with the object.  Don't forget that some
                OpenGL objects don't actually die when you delete them, only
                when they are no longer referenced.
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">object *bugle_object_get_current(const object_class *klass);
void bugle_object_set_current(object_class *klass, object *obj);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                These functions get and set the current object, within the
                context of that class. For example, when setting the current
                display list, it is made current within the current OpenGL
                context, and switching OpenGL contexts will yield a new
                current display list. It is legal for the current object to be
                <symbol>NULL</symbol>, and in fact this is the initial state.
            </para>
            <para>
                If the current object is destroyed, then <symbol>NULL</symbol>
                becomes the new current object.
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">void *bugle_object_get_data(object *obj, object_view *view);
void *bugle_object_get_current_data(object_class *klass, object *obj);</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                This retrieves the view data stored in
                <parameter>obj</parameter>. The <parameter>view</parameter> is
                the handle returned by
                <function>bugle_object_view_register</function>. One can get
                the data from the current object with the convenience function
                <function>bugle_object_get_current_data</function> (if it is
                certain that the current object is not <symbol>NULL</symbol>).
            </para>
        </sect2>
        <sect2 id="extending-objects-threads">
            <title>Thread safety</title>
            <para>
                Manipulations of a particular class must be serialised, as
                there is no internal protection against concurrent access.
                This is seldom a problem since modification of a class is
                usually done during startup and shutdown, which are
                serialised.
            </para>
            <para>
                The object manipulation functions are safe to use
                concurrently, since the object structures are not modified.
                Setting the current object is thread-safe unless the class has
                a parent in the scope tree and an instance of that parent is
                current in more than one thread. Even then, it is safe on most
                reasonable machines, since setting the current object amounts
                to overwriting a single pointer. Note that
                <function>bugle_object_new</function> and
                <function>bugle_object_free</function> may both set the
                current object implicitly.
            </para>
            <para>
                Manipulation of the view data is of course up to each
                individual registrant, and it is responsible for managing any
                concurrency issues that arise.
            </para>
        </sect2>
    </sect1>

    <sect1 id="extending-utility">
        <title>Utility functions and filter-sets</title>
        <para>
            The functions listed above are the minimal set needed to write a
            filter-set. This section describes a number of utilities which
            simplify the job of writing a more powerful filter-set. Most of
            the functions described here are defined in <filename
                class="headerfile">src/glutils.h</filename>.
        </para>
        <sect2 id="extending-utility-beginend">
            <title>Begin/end checking</title>
            <para>
                Many OpenGL functions may not be called between
                <function>glBegin</function> and <function>glEnd</function>.
                To facilitate checking for this, the
                <systemitem>trackbeginend</systemitem> filter-set provides the
                boolean function <function>bugle_in_begin_end</function> which
                indicates whether the current context is in this state. This
                function is defined in the header <filename
                    class="headerfile">src/tracker.h</filename>. You must also
                also call <code
                    language="cpp">bugle_filter_post_queries_begin_end("<replaceable>filtername</replaceable>")</code>
                as part of the filter-set initialisation, for filters that run
                after invocation. Failing to do so may yield incorrect results
                during interception of <function>glBegin</function> or
                <function>glEnd</function>.
            </para>
            <warning>
                <para>
                    Do not call
                    <function>bugle_filter_post_queries_begin_end</function>
                    for filters that run before invocation, or you will
                    generate a cyclic dependency.
                </para>
            </warning>
            <para>
                If there is no current OpenGL context, this call will return
                <symbol>true</symbol>. This means that whenever the call
                returns false, it should be safe to issue OpenGL
                commands. Refer to <xref linkend="extending-utility-calling"/>
                for more information
                about making OpenGL calls from within a filter-set.
            </para>
        </sect2>
        <sect2 id="extending-utility-error">
            <title>Error checking</title>
            <para>
                It is often useful to know whether an OpenGL call generated an
                OpenGL error. If your filter-set
                <replaceable>filterset</replaceable> wishes to do this, it
                must call <code
                    language="cpp">bugle_filter_set_queries_error("<replaceable>filterset</replaceable>")</code>
                during library initialisation. To actually retrieve the error,
                call <code
                    language="cpp">bugle_call_get_error(data->call_object)</code>.
            </para>
            <para>
                This mechanism is not totally reliable. It is illegal to call
                <function>glGetError</function> when there is no OpenGL
                context or when between <function>glBegin</function> and
                <function>glEnd</function>. In these cases,
                <symbol>GL_NO_ERROR</symbol> may be returned even though the
                call did not succeed.
            </para>
            <para>
                In the current implementation, enabling this mechanism also
                drasticly reduces performance, as every function call is
                intercepted to call <function>glGetError</function>.
            </para>
        </sect2>
        <sect2 id="extending-utility-calling">
            <title>Making calls to OpenGL</title>
            <para>
                If you attempt to call an OpenGL function directly, the
                interception system will intercept the call and &bugle; will
                be entered recursively. There is protection against this (the
                call will be forwarded to the real OpenGL library without
                further action), but it is nevertheless a performance hit. To
                call an OpenGL function, you should prefix the name with
                <literal>CALL_</literal>, for example,
                <function>CALL_glGetIntegerv</function>. This will also work
                for extension functions, but you must ensure that the
                extension is available at both compile and run time; this is
                described in <xref linkend="extending-utility-extensions"/>.
            </para>
            <para>
                For OpenGL (as opposed to GLX) functions, it is also important
                to have a valid context which is not inside begin/end. Some
                utilities are provided to simplify the interaction with
                begin/end checking. A filter-set that wishes to make OpenGL
                calls must be registered at library initialisation time with
            </para>
            <programlisting>bugle_filter_set_renders("<replaceable>filter-set</replaceable>");</programlisting>
            <para>
                and any filters that make such calls and which ran after
                invocation must be registered during filter-set initialisation
                with
            </para>
            <programlisting>bugle_filter_post_renders("<replaceable>filter</replaceable>");</programlisting>
            <para>
                To begin a section of code that wishes to make OpenGL function
                calls, call <code>bugle_begin_internal_render()</code>. It
                will return a boolean, indicating whether it is safe to
                proceed. If it is, you must terminate that block of code by
                calling
                <code>bugle_end_internal_render("<replaceable>name</replaceable>", true);</code>
                The first parameter is
                a descriptive name for the section of code (typically the
                name of the containing function), which is logged if the code
                generates any OpenGL errors. Setting the second parameter to
                false, however, suppresses the warning, which should only be
                done if you have intentionally written code that may generate
                OpenGL errors.
            </para>
        </sect2>
        <sect2 id="extending-utility-extensions">
            <title>Checking for OpenGL extensions</title>
            <para>
                The following functions simplify checking for the presence
                of an OpenGL extension in the current context:
            </para>
            <funcsynopsis>
                <funcsynopsisinfo language="cpp">#include "src/tracker.h"

bool bugle_gl_has_extension(<replaceable>BUGLE_GL_EXT_some_extension</replaceable>);
bool bugle_gl_has_extension_group(<replaceable>BUGLE_GL_EXT_some_extension</replaceable>);

bugle_filter_set_depends(<replaceable>"myfilterset"</replaceable>, "trackextensions");</funcsynopsisinfo>
            </funcsynopsis>
            <para>
                An extension group is a set of extensions with similar
                functionality. For example, when passing
                <symbol>BUGLE_GL_EXT_pixel_buffer_object</symbol> to
                <function>bugle_gl_has_extension_group</function> will return
                <symbol>true</symbol> if any one of
                <symbol>GL_EXT_pixel_buffer_object</symbol>,
                <symbol>GL_ARB_pixel_buffer_object</symbol>, or OpenGL 2.1 is
                available.
            </para>
            <note>
                <para>
                    Unlike with function groups, there associations are not
                    usually symmetric, because extensions supersede others
                    rather than having identical functionality.
                </para>
            </note>
            <para>
                There are also some special extension groups, defined in
                <filename>gentokens/genexts.perl</filename>, that are
                convenient ways to test for certain functionality that is
                provided by several extensions but is not the sole function of
                any of them.
            </para>
            <para>
                Apart from extensions, you can also check for OpenGL versions
                using symbols such as <symbol>BUGLE_GL_VERSION_2_0</symbol>.
                The list of extensions is parsed once per context, so these
                checks are quite cheap. If there is no current context, the
                function returns <symbol>false</symbol>.
            </para>
            <para>
                Remember that you also need to do a compile-time check before
                using any of these symbols; see 
                <xref linkend="extending-guidelines-oglextensions"/> for
                details.
            </para>
        </sect2>
    </sect1>
</chapter>
