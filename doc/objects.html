<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>BuGLe object management</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<h1>BuGLe object management</title>
<h2>Introduction</h2>
<p>
This file documents the object layer in BuGLe. It is NOT an OOP layer
to add C++-like features to C. So what is it? Well, OpenGL has a number
of types of &ldquo;object&rdquo; &mdash; things like contexts, drawables, display lists, 
texture objects etc &mdash; and various bits of code in BuGLe want to
associate data with these objects. The object layer makes this easier.
It should be understood, however, that the object layer has no
knowledge of OpenGL. It is up to you to track the OpenGL calls that
manage objects and mirror them within the the object layer (some of
this is done in the core code, particularly context and display list
tracking).
</p>

<p>
The important concepts are:
</p>
<dl>
<dt>class (<code>bugle_object_class *</code>)</dt>
<dd>A class is like an OOP class, in that
objects are instanciations of classes with data</dd>
<dt>registrant</dt>
<dd>Several units of code may wish to attach storage to an object, and
they need to be kept separate from each other. Each such unit is known
as a registrant. There is no explicit structure to represent
registrants.</dd>
<dt>object (<code>void *</code>)</dt>
<dd>An object holds all the data that all registrants have attached to
a GL object. It should be treated as being opaque.</dd>
<dt>view (<code>void *</code>)</dt>
<dd>A view is a pointer to the data that a single
registrant attached to a GL object. The interpretation of the data is
up to the registrant.</dd>
</dl>
<p>
The object system also has a concept of scope. This has nothing to do
with inheritence. It refers to the scope at which an object can be
considered to be <em>current</em>. For example, each thread has a
current context, and each context may have a current display list.
BuGLe allows you so specify what the current object for each class is
(which may be <code>NULL</code>), and retrieve it later.
</p>

<h2>Class management functions</h2>
<p>
The class management functions are not thread-safe; any concurrent access
to the same class should be protected with a mutex.</p>
<dl>
<dt><code>bugle_object_class_init(object_class *<em>klass</em>,
                                  object_class *<em>parent</em>)</code></dt>
<dd>Initialises the structures for a class. The
<em>parent</em> field may be set to either <code>NULL</code> (in which case
the scope of the class is the thread), or an existing class (in which case
the scope is the parent class).</dd>
<dt><code>bugle_object_class_clear(object_class *<em>klass</em>)</code></dt>
<dd>Frees the structures for a class (although it does not delete any instances,
which should be deleted first).</dd>
<dt><code>bugle_object_class_register(object_class *<em>klass</em>,
                                      void (*<em>constructor</em>)(const void *, void *),
                                      void (*<em>destructor</em>)(void *),
                                      size_t <em>size</em>)</code></dt>
<dd>Called by each registrant to request <em>size</em> bytes of storage
within a class. The constructor is documented later;
the destructor is simply given the view
of the object, so that it can do cleanup (but it must
<strong>not</strong> try to free the view itself). Both the constructor
and destructor may be <code>NULL</code>.
The size may be zero, if one only wants notification of object creation
and destruction through the constructor and destructor. The return
value is of type <code>size_t</code>, and acts as a handle in other
calls.</dd>
</dl>

<h2>Object management functions</h2>
<p>
The object management functions do not modify the
<code>object_class</code> structures. Hence they are thread-safe,
provided that they are not used concurrently with the class management
functions. The exception is that if an object of class <em>A</em>is
current to more than one thread, then setting the current object of
class <em>B</em> whose scope is inside that of class <em>A</em>, may
not be thread-safe.
</p>
<dl>
<dt><code>bugle_object_new(object_class *<em>klass</em>,
                           const void *<em>key</em>,
                           bool <em>make_current</em>)</code></dt>
<dd>Instantiate an instance of the given class. Firstly, if
<em>make_current</em> is <code>true</code> then the new object is
immediately made the current object of its class. Then, for each
registrant the constructor is called to initialise the data in its
view. The constructor is passed <em>key</em> and the view (the
<em>key</em> parameter exists only to pass extra information to the
constructor, usually about the associated GL object). Where no
constructor is specified, the view is filled with zeros.</dd>
<dt><code>bugle_object_delete(object_class *<em>klass</em>,
                              void *<em>object</em>)</code></dt>
<dd>For each registrant, calls the destructor (if any) with the view.
It then frees the memory associated with the object.
Don't forget that some GL objects don't actually die when you delete
them, only when they are no longer referenced. Also be sure to pass
an object, <strong>not</strong> a view.</dd>
<dt><code>bugle_object_get_data(object_class *<em>klass</em>,
                                void *<em>object</em>,
                                size_t <em>handle</em>)</code></dt>
<dd>Maps an object to the view for a particular registrant (given by
the <em>handle</em> returned by
<code>bugle_object_class_register</code>).</dd>
</dl>

<h2>Setting and fetching the current object</h2>
<dl>
<dt><code>bugle_object_get_current(const object_class *<em>klass</em>)</code></dt>
<dd>Returns the current object of the given class.</dd>
<dt><code>bugle_object_get_current_data(const object_class *<em>klass</em>, size_t <em>handle</em>)</code></dt>
<dd>A shortcut to combine <code>bugle_object_get_current</code> and
<code>bugle_object_get_data</code>.</dd>
<dt><code>bugle_object_set_current(const object_class *<em>klass</em>, void *<em>object</em>)</code></dt>
<dd>Sets the current object of class <em>klass</em> to <em>object<em>.</dd>
</dl>
</body>
</html>
